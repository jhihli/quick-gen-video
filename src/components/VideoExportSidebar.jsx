import React, { useState, useContext, useEffect } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { AppContext } from '../context/AppContext'
import { useLanguage } from '../context/LanguageContext'
import { useSessionHeartbeat } from '../hooks/useSessionHeartbeat'
import DownloadOptions from './DownloadOptions'

function VideoExportSidebar({ onNewVideo, onFeedback }) {
  const {
    photos,
    selectedMusic,
    generatedVideo,
    setVideo,
    isProcessing,
    generationProgress,
    currentJobId,
    generationError,
    setIsProcessing,
    setGenerationProgress,
    setCurrentJobId,
    setGenerationError,
    clearGenerationState,
    slideAvatars,
    slideAvatarPositions,
    slideAvatarSettings,
    hasAnyAvatars
  } = useContext(AppContext)
  const { t } = useLanguage()
  const { sessionId } = useSessionHeartbeat()
  const [localVideoData, setLocalVideoData] = useState(generatedVideo)
  const [showError, setShowError] = useState(false)
  const [qrCodeDataUrl, setQrCodeDataUrl] = useState(null)
  const [loadingQR, setLoadingQR] = useState(false)
  const [showQrCode, setShowQrCode] = useState(false)
  const [showSuccessMessage, setShowSuccessMessage] = useState(true)
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false)
  const [initialStateCheckComplete, setInitialStateCheckComplete] = useState(false)

  // Handle reconnection to ongoing jobs on component mount
  useEffect(() => {
    if (currentJobId && isProcessing && !localVideoData) {
      console.log('üîÑ Reconnecting to ongoing job:', currentJobId)
      // Resume polling for existing job
      const pollExistingJob = async () => {
        try {
          const progressResponse = await fetch(`/api/video-progress/${currentJobId}`)

          if (!progressResponse.ok) {
            console.error(`‚ùå Progress request failed: ${progressResponse.status}`)
            if (progressResponse.status === 404) {
              // Job not found, clear the state
              console.log('Job not found, clearing generation state')
              clearGenerationState()
              return
            }
            throw new Error(t('failedToGetProgress'))
          }

          const progressData = await progressResponse.json()

          if (progressData.status === 'error') {
            console.error('‚ùå Video processing error:', progressData.message)
            setGenerationError(progressData.message || t('videoProcessingFailed'))
            setIsProcessing(false)
            return
          }

          setGenerationProgress(progressData.progress || 0)

          if (progressData.status === 'completed' && progressData.videoData) {
            const newVideoData = {
              url: progressData.videoData.url,
              tempUrl: progressData.videoData.tempUrl,
              filename: progressData.videoData.filename,
              fileSize: progressData.videoData.size
            }
            setLocalVideoData(newVideoData)
            setVideo(newVideoData) // Update context
            setIsProcessing(false)
            setGenerationProgress(100)
            setCurrentJobId(null)
            setInitialStateCheckComplete(true)
          } else if (progressData.status === 'processing' || progressData.status === 'initializing') {
            setTimeout(pollExistingJob, 1000)
          }
        } catch (error) {
          console.error('Reconnection polling error:', error)
          setIsProcessing(false)
          setGenerationError(error.message || t('unknownErrorOccurred'))
          setInitialStateCheckComplete(true)
        }
      }

      // Start polling immediately
      pollExistingJob()
    } else {
      // No existing job to reconnect to, mark initial check as complete
      setInitialStateCheckComplete(true)
    }
  }, []) // Only run on mount

  // Auto-start generation when component mounts if we have photos and music but no video
  useEffect(() => {
    // Only auto-generate once per component lifecycle and avoid during errors
    // Wait for initial state check to complete to prevent race conditions
    if (initialStateCheckComplete && photos.length > 0 && selectedMusic && !localVideoData && !isProcessing && !hasAutoGenerated && !generationError && !currentJobId) {
      setHasAutoGenerated(true)

      // Add small delay to allow state synchronization and prevent race conditions
      setTimeout(() => {
        // Double-check state before actually triggering generation
        if (!isProcessing && !currentJobId) {
          handleGenerateVideo()
        } else {
        }
      }, 100)
    }
  }, [initialStateCheckComplete, photos.length, selectedMusic, localVideoData, isProcessing, hasAutoGenerated, generationError, currentJobId])

  // Update local video data when context changes
  useEffect(() => {
    setLocalVideoData(generatedVideo)
    // Reset QR code when video data changes
    setQrCodeDataUrl(null)
    setShowQrCode(false)
    // Show success message when new video is generated
    if (generatedVideo) {
      setShowSuccessMessage(true)
    }
  }, [generatedVideo])

  // Reset auto-generation flag when photos or music change significantly
  useEffect(() => {
    // Reset if no photos or no music (user is starting over)
    if (photos.length === 0 || !selectedMusic) {
      setHasAutoGenerated(false)
    }
  }, [photos.length, selectedMusic])

  // Auto-hide success message after 2 seconds
  useEffect(() => {
    if (localVideoData && showSuccessMessage) {
      const timer = setTimeout(() => {
        setShowSuccessMessage(false)
      }, 2000) // 2 seconds

      return () => clearTimeout(timer)
    }
  }, [localVideoData, showSuccessMessage])

  const showErrorMessage = (message) => {
    setGenerationError(message)
    setShowError(true)

    // Auto-hide after 3 seconds
    setTimeout(() => {
      setShowError(false)
      setTimeout(() => setGenerationError(null), 500)
    }, 3000)
  }

  const handleQRToggle = async () => {
    if (showQrCode) {
      // Hide QR code
      setShowQrCode(false)
      return
    }

    // Show QR code - generate if not already generated
    if (!qrCodeDataUrl && !loadingQR) {
      await generateQRCode()
    } else if (qrCodeDataUrl) {
      setShowQrCode(true)
    }
  }

  const generateQRCode = async () => {
    if (!localVideoData?.tempUrl || loadingQR) return

    setLoadingQR(true)
    try {
      // Use qrcode library directly (client-side generation like previous code)
      const QRCode = await import('qrcode')
      
      // Create full URL for QR code (following previous pattern)
      const baseUrl = window.location.origin
      const fullTempUrl = `${baseUrl}${localVideoData.tempUrl}?mobile=true&qr=true&t=${Date.now()}`
      
      console.log('Generating QR Code for URL:', fullTempUrl)
      
      const qrCodeDataUrl = await QRCode.toDataURL(fullTempUrl, {
        errorCorrectionLevel: 'M',
        type: 'image/png',
        quality: 0.92,
        margin: 2,
        color: {
          dark: '#000000',
          light: '#FFFFFF'
        },
        width: 256
      })
      
      setQrCodeDataUrl(qrCodeDataUrl)
      setShowQrCode(true)
      
    } catch (error) {
      console.error('QR code generation error:', error)
      showErrorMessage('Failed to generate QR code: ' + error.message)
    } finally {
      setLoadingQR(false)
    }
  }

  const handleDownload = () => {
    if (!localVideoData?.tempUrl) return
    
    // Create download link and trigger download
    const link = document.createElement('a')
    link.href = localVideoData.tempUrl + '?download=true'
    link.download = localVideoData.filename || 'tkvgen-video.mp4'
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  }

  const handleGenerateVideo = async () => {
    
    if (!photos?.length || !selectedMusic) {
      showErrorMessage(t('pleaseFillRequirements'))
      return
    }

    // Prevent duplicate requests
    if (isProcessing || currentJobId) {
      showErrorMessage('Video generation already in progress. Please wait...')
      return
    }

    setIsProcessing(true)
    setGenerationProgress(0)
    setGenerationError(null)

    try {
      // Prepare JSON payload (server expects JSON, not FormData)
      const payload = {
        photos: photos, // Photos array with url property from upload response
        music: selectedMusic, // Music object with url property from upload response
        sessionId: sessionId,
        // Avatar data for overlay processing
        avatars: hasAnyAvatars ? {
          slideAvatars,
          slideAvatarPositions,
          slideAvatarSettings
        } : null
      }


      // Start video generation
      const response = await fetch('/api/generate-video', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      })

      if (!response.ok) {
        // Only log non-429 errors to avoid console noise for expected rate limiting
        if (response.status !== 429) {
          console.error('Server response:', response.status, response.statusText)
        }
        let errorData
        try {
          errorData = await response.json()
          // Only log non-429 error data to reduce console noise
          if (response.status !== 429) {
            console.error('Error data:', errorData)
          }
        } catch (e) {
          console.error('Failed to parse error response:', e)
          errorData = { message: `HTTP ${response.status}: ${response.statusText}` }
        }
        
        // Special handling for rate limiting - don't allow immediate retry
        if (response.status === 429) {
          // Don't reset hasAutoGenerated immediately to prevent infinite loops
          setTimeout(() => {
            setHasAutoGenerated(false) // Allow retry after delay
          }, 30000) // 30 second delay before allowing retry

          // Show user-friendly message for concurrent generation
          showErrorMessage(errorData.error || 'Video generation already in progress. Please wait...')
          setIsProcessing(false)
          return // Don't throw error for 429, just return gracefully
        }

        throw new Error(errorData.message || errorData.error || t('generationFailed'))
      }

      const data = await response.json()
      const jobId = data.jobId

      // Store job ID in persistent state
      setCurrentJobId(jobId)

      // Poll for progress
      const pollProgress = async () => {
        try {
          const progressResponse = await fetch(`/api/video-progress/${jobId}`)
          
          if (!progressResponse.ok) {
            console.error(`‚ùå Progress request failed: ${progressResponse.status}`)
            throw new Error(t('failedToGetProgress'))
          }

          const progressData = await progressResponse.json()
          
          if (progressData.status === 'error') {
            console.error('‚ùå Video processing error:', progressData.message)
            throw new Error(progressData.message || t('videoProcessingFailed'))
          }
          
          setGenerationProgress(progressData.progress || 0)

          if (progressData.status === 'completed' && progressData.videoData) {
            const newVideoData = {
              url: progressData.videoData.url,
              tempUrl: progressData.videoData.tempUrl,
              filename: progressData.videoData.filename,
              fileSize: progressData.videoData.size
            }
            setLocalVideoData(newVideoData)
            setVideo(newVideoData) // Update context
            setIsProcessing(false)
            setGenerationProgress(100)
            setCurrentJobId(null) // Clear job ID when completed
          } else if (progressData.status === 'processing' || progressData.status === 'initializing') {
            setTimeout(pollProgress, 1000)
          }
        } catch (error) {
          console.error('Progress polling error:', error)
          setIsProcessing(false)
          showErrorMessage(error.message || t('unknownErrorOccurred'))
        }
      }

      // Start polling
      setTimeout(pollProgress, 1000)

    } catch (error) {
      console.error('Video generation error:', error)
      setIsProcessing(false)
      showErrorMessage(error.message || t('generationFailed'))
    }
  }

  return (
    <div className="p-6 space-y-6 h-full overflow-y-auto">
      {/* Generation Status */}
      {isProcessing && (
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          className="bg-gradient-to-r from-blue-500/10 to-cyan-500/10 border border-blue-400/30 rounded-xl p-4"
        >
          <div className="flex items-center space-x-3 mb-3">
            <div className="w-6 h-6 border-2 border-blue-400 border-t-transparent rounded-full animate-spin"></div>
            <span className="text-blue-300 font-medium">{t('generatingVideo')}</span>
          </div>
          
          {/* Progress Bar */}
          <div className="w-full bg-gray-700 rounded-full h-2 overflow-hidden">
            <motion.div
              className="h-2 bg-gradient-to-r from-blue-500 to-cyan-500 rounded-full"
              initial={{ width: 0 }}
              animate={{ width: `${generationProgress}%` }}
              transition={{ duration: 0.5, ease: "easeOut" }}
            />
          </div>
          <p className="text-blue-200 text-sm mt-2">{Math.round(generationProgress)}% {t('completed')}</p>
        </motion.div>
      )}

      {/* Error Message */}
      <AnimatePresence>
        {showError && generationError && (
          <motion.div
            initial={{ opacity: 0, y: -20, scale: 0.95 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -20, scale: 0.95 }}
            className="bg-gradient-to-r from-red-500/10 to-rose-500/10 border border-red-400/30 rounded-xl p-4"
          >
            <div className="flex items-center space-x-3">
              <svg className="w-5 h-5 text-red-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              <span className="text-red-300 text-sm">{generationError}</span>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Video Ready - Download Options */}
      {localVideoData && !isProcessing && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="space-y-6"
        >
          {/* Success Message - Auto-hide after 2 seconds */}
          <AnimatePresence>
            {showSuccessMessage && (
              <motion.div
                initial={{ opacity: 0, scale: 0.95 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.95 }}
                transition={{ duration: 0.3 }}
                className="bg-gradient-to-r from-green-500/10 to-emerald-500/10 border border-green-400/30 rounded-xl p-4"
              >
                <div className="flex items-center space-x-3">
                  <svg className="w-6 h-6 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                  <span className="text-green-300 font-medium">{t('videoGeneratedSuccessfully')}</span>
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* QR Code Display - Minimalist */}
          <AnimatePresence>
            {showQrCode && qrCodeDataUrl && (
              <motion.div 
                className="flex justify-center"
                initial={{ opacity: 0, scale: 0.8, y: 20 }}
                animate={{ opacity: 1, scale: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.8, y: -20 }}
                transition={{ duration: 0.3 }}
              >
                <div className="bg-white rounded-lg p-2">
                  <img 
                    src={qrCodeDataUrl} 
                    alt="QR Code" 
                    className="w-24 h-24"
                  />
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* All Action Buttons - Single Column, Centered */}
          <motion.div 
            className="flex flex-col items-center space-y-3 w-full max-w-xs mx-auto"
            initial={{ scale: 0.95 }}
            animate={{ scale: 1 }}
            transition={{ duration: 0.3 }}
          >
            {/* Download Button */}
            <motion.button
              onClick={handleDownload}
              className="w-full bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-700 hover:to-cyan-700 text-white font-semibold py-3 px-4 rounded-xl shadow-lg transition-all duration-300 flex items-center justify-center space-x-2"
              whileHover={{ scale: 1.02, boxShadow: "0 10px 30px -10px rgba(59, 130, 246, 0.4)" }}
              whileTap={{ scale: 0.98 }}
            >
              <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
              </svg>
              <span className="text-sm">Download</span>
            </motion.button>

            {/* QR Code Button */}
            <motion.button
              onClick={handleQRToggle}
              disabled={loadingQR}
              className="w-full bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed text-white font-semibold py-3 px-4 rounded-xl shadow-lg transition-all duration-300 flex items-center justify-center space-x-2"
              whileHover={!loadingQR ? { scale: 1.02, boxShadow: "0 10px 30px -10px rgba(34, 197, 94, 0.4)" } : {}}
              whileTap={!loadingQR ? { scale: 0.98 } : {}}
            >
              {loadingQR ? (
                <>
                  <motion.div
                    className="w-4 h-4 border-2 border-white border-t-transparent rounded-full"
                    animate={{ rotate: 360 }}
                    transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
                  />
                </>
              ) : (
                <>
                  <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M3 11h8V3H3v8zm2-6h4v4H5V5zM13 3v8h8V3h-8zm6 6h-4V5h4v4zM3 21h8v-8H3v8zm2-6h4v4H5v-4z"/>
                    <path d="M15 19h2v2h-2zM19 19h2v2h-2zM17 17h2v2h-2zM15 15h2v2h-2zM17 21h2v2h-2z"/>
                  </svg>
                  <span className="text-sm">{showQrCode ? t('hideQR') : 'QR Code'}</span>
                </>
              )}
            </motion.button>

            {/* New Video Button */}
            <motion.button
              onClick={onNewVideo}
              className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 px-4 rounded-xl font-semibold hover:shadow-lg hover:shadow-purple-500/25 transition-all duration-200 flex items-center justify-center space-x-2"
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
              </svg>
              <span className="text-sm">{t('createNewVideo')}</span>
            </motion.button>
            
            {/* Feedback Button */}
            <motion.button
              onClick={onFeedback}
              className="w-full bg-white/5 backdrop-blur-sm border border-white/10 text-white py-3 px-4 rounded-xl font-semibold hover:bg-white/10 hover:border-white/20 transition-all duration-200 flex items-center justify-center space-x-2"
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                <path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4l4 4 4-4h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
              </svg>
              <span className="text-sm">{t('feedback')}</span>
            </motion.button>
          </motion.div>
        </motion.div>
      )}

      {/* No Video Yet - Generate Button */}
      {!localVideoData && !isProcessing && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="space-y-4"
        >
          <motion.button
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            onClick={handleGenerateVideo}
            disabled={!photos?.length || !selectedMusic}
            className="w-full bg-gradient-to-r from-blue-500 to-cyan-500 disabled:from-gray-600 disabled:to-gray-700 text-white py-4 px-6 rounded-xl font-medium hover:shadow-lg hover:shadow-blue-500/25 transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50"
          >
            {t('generateVideo')}
          </motion.button>

          {(!photos?.length || !selectedMusic) && (
            <p className="text-white/50 text-sm text-center">
              {t('pleaseFillRequirements')}
            </p>
          )}
        </motion.div>
      )}

    </div>
  )
}

export default VideoExportSidebar