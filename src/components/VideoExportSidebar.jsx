import React, { useState, useContext, useEffect } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { AppContext } from '../context/AppContext'
import { useLanguage } from '../context/LanguageContext'
import { useSessionHeartbeat } from '../hooks/useSessionHeartbeat'
import DownloadOptions from './DownloadOptions'

function VideoExportSidebar({ onNewVideo }) {
  const {
    photos,
    selectedMusic,
    generatedVideo,
    setVideo,
    isProcessing,
    generationProgress,
    currentJobId,
    generationError,
    setIsProcessing,
    setGenerationProgress,
    setCurrentJobId,
    setGenerationError,
    clearGenerationState,
    slideAvatars,
    slideAvatarPositions,
    slideAvatarSettings,
    hasAnyAvatars
  } = useContext(AppContext)
  const { t } = useLanguage()
  const { sessionId } = useSessionHeartbeat()
  const [localVideoData, setLocalVideoData] = useState(generatedVideo)
  const [showError, setShowError] = useState(false)
  const [qrCodeDataUrl, setQrCodeDataUrl] = useState(null)
  const [loadingQR, setLoadingQR] = useState(false)
  const [showQrCode, setShowQrCode] = useState(false)
  const [showSuccessMessage, setShowSuccessMessage] = useState(true)
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false)
  const [initialStateCheckComplete, setInitialStateCheckComplete] = useState(false)

  // Handle reconnection to ongoing jobs on component mount
  useEffect(() => {
    if (currentJobId && isProcessing && !localVideoData) {
      console.log('🔄 Reconnecting to ongoing job:', currentJobId)
      // Resume polling for existing job
      const pollExistingJob = async () => {
        try {
          const progressResponse = await fetch(`/api/video-progress/${currentJobId}`)

          if (!progressResponse.ok) {
            console.error(`❌ Progress request failed: ${progressResponse.status}`)
            if (progressResponse.status === 404) {
              // Job not found, clear the state
              console.log('Job not found, clearing generation state')
              clearGenerationState()
              return
            }
            throw new Error(t('failedToGetProgress'))
          }

          const progressData = await progressResponse.json()

          if (progressData.status === 'error') {
            console.error('❌ Video processing error:', progressData.message)
            setGenerationError(progressData.message || t('videoProcessingFailed'))
            setIsProcessing(false)
            return
          }

          setGenerationProgress(progressData.progress || 0)

          if (progressData.status === 'completed' && progressData.videoData) {
            const newVideoData = {
              url: progressData.videoData.url,
              tempUrl: progressData.videoData.tempUrl,
              filename: progressData.videoData.filename,
              fileSize: progressData.videoData.size
            }
            setLocalVideoData(newVideoData)
            setVideo(newVideoData) // Update context
            setIsProcessing(false)
            setGenerationProgress(100)
            setCurrentJobId(null)
            setInitialStateCheckComplete(true)
          } else if (progressData.status === 'processing' || progressData.status === 'initializing') {
            setTimeout(pollExistingJob, 1000)
          }
        } catch (error) {
          console.error('Reconnection polling error:', error)
          setIsProcessing(false)
          setGenerationError(error.message || t('unknownErrorOccurred'))
          setInitialStateCheckComplete(true)
        }
      }

      // Start polling immediately
      pollExistingJob()
    } else {
      // No existing job to reconnect to, mark initial check as complete
      setInitialStateCheckComplete(true)
    }
  }, []) // Only run on mount

  // Auto-start generation when activeMode is 'generate' (triggered by Generate button click)
  useEffect(() => {
    // Only auto-generate once per component lifecycle and avoid during errors
    // Wait for initial state check to complete to prevent race conditions
    if (initialStateCheckComplete && photos.length > 0 && selectedMusic && !localVideoData && !isProcessing && !hasAutoGenerated && !generationError && !currentJobId) {
      setHasAutoGenerated(true)

      // Add small delay to allow state synchronization and prevent race conditions
      setTimeout(() => {
        // Double-check state before actually triggering generation
        if (!isProcessing && !currentJobId) {
          handleGenerateVideo()
        }
      }, 100)
    }
  }, [initialStateCheckComplete, photos.length, selectedMusic, localVideoData, isProcessing, hasAutoGenerated, generationError, currentJobId])

  // Update local video data when context changes
  useEffect(() => {
    setLocalVideoData(generatedVideo)
    // Reset QR code when video data changes
    setQrCodeDataUrl(null)
    setShowQrCode(false)
    // Show success message when new video is generated
    if (generatedVideo) {
      setShowSuccessMessage(true)
    }
  }, [generatedVideo])

  // Reset auto-generation flag when photos or music change significantly
  useEffect(() => {
    // Reset if no photos or no music (user is starting over)
    if (photos.length === 0 || !selectedMusic) {
      setHasAutoGenerated(false)
    }
  }, [photos.length, selectedMusic])

  // Auto-hide success message after 2 seconds
  useEffect(() => {
    if (localVideoData && showSuccessMessage) {
      const timer = setTimeout(() => {
        setShowSuccessMessage(false)
      }, 2000) // 2 seconds

      return () => clearTimeout(timer)
    }
  }, [localVideoData, showSuccessMessage])

  const showErrorMessage = (message) => {
    setGenerationError(message)
    setShowError(true)

    // Auto-hide after 3 seconds
    setTimeout(() => {
      setShowError(false)
      setTimeout(() => setGenerationError(null), 500)
    }, 3000)
  }

  const handleQRToggle = async () => {
    if (showQrCode) {
      // Hide QR code
      setShowQrCode(false)
      return
    }

    // Show QR code - generate if not already generated
    if (!qrCodeDataUrl && !loadingQR) {
      await generateQRCode()
    } else if (qrCodeDataUrl) {
      setShowQrCode(true)
    }
  }

  const generateQRCode = async () => {
    if (!localVideoData?.tempUrl || loadingQR) return

    setLoadingQR(true)
    try {
      // Use qrcode library directly (client-side generation like previous code)
      const QRCode = await import('qrcode')
      
      // Create full URL for QR code (following previous pattern)
      const baseUrl = window.location.origin
      const fullTempUrl = `${baseUrl}${localVideoData.tempUrl}?mobile=true&qr=true&t=${Date.now()}`
      
      console.log('Generating QR Code for URL:', fullTempUrl)
      
      const qrCodeDataUrl = await QRCode.toDataURL(fullTempUrl, {
        errorCorrectionLevel: 'M',
        type: 'image/png',
        quality: 0.92,
        margin: 2,
        color: {
          dark: '#000000',
          light: '#FFFFFF'
        },
        width: 256
      })
      
      setQrCodeDataUrl(qrCodeDataUrl)
      setShowQrCode(true)
      
    } catch (error) {
      console.error('QR code generation error:', error)
      showErrorMessage('Failed to generate QR code: ' + error.message)
    } finally {
      setLoadingQR(false)
    }
  }

  const handleDownload = () => {
    if (!localVideoData?.tempUrl) return
    
    // Create download link and trigger download
    const link = document.createElement('a')
    link.href = localVideoData.tempUrl + '?download=true'
    link.download = localVideoData.filename || 'tkvgen-video.mp4'
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  }

  const handleGenerateVideo = async () => {
    
    if (!photos?.length || !selectedMusic) {
      showErrorMessage(t('pleaseFillRequirements'))
      return
    }

    // Prevent duplicate requests
    if (isProcessing || currentJobId) {
      showErrorMessage('Video generation already in progress. Please wait...')
      return
    }

    setIsProcessing(true)
    setGenerationProgress(0)
    setGenerationError(null)

    try {
      // Prepare JSON payload (server expects JSON, not FormData)
      const payload = {
        photos: photos, // Photos array with url property from upload response
        music: selectedMusic, // Music object with url property from upload response
        sessionId: sessionId,
        // Avatar data for overlay processing
        avatars: hasAnyAvatars ? {
          slideAvatars,
          slideAvatarPositions,
          slideAvatarSettings
        } : null
      }


      // Start video generation
      const response = await fetch('/api/generate-video', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      })

      if (!response.ok) {
        // Only log non-429 errors to avoid console noise for expected rate limiting
        if (response.status !== 429) {
          console.error('Server response:', response.status, response.statusText)
        }
        let errorData
        try {
          errorData = await response.json()
          // Only log non-429 error data to reduce console noise
          if (response.status !== 429) {
            console.error('Error data:', errorData)
          }
        } catch (e) {
          console.error('Failed to parse error response:', e)
          errorData = { message: `HTTP ${response.status}: ${response.statusText}` }
        }
        
        // Special handling for rate limiting - don't allow immediate retry
        if (response.status === 429) {
          // Don't reset hasAutoGenerated immediately to prevent infinite loops
          setTimeout(() => {
            setHasAutoGenerated(false) // Allow retry after delay
          }, 30000) // 30 second delay before allowing retry

          // Show user-friendly message for concurrent generation
          showErrorMessage(errorData.error || 'Video generation already in progress. Please wait...')
          setIsProcessing(false)
          return // Don't throw error for 429, just return gracefully
        }

        throw new Error(errorData.message || errorData.error || t('generationFailed'))
      }

      const data = await response.json()
      const jobId = data.jobId

      // Store job ID in persistent state
      setCurrentJobId(jobId)

      // Poll for progress
      const pollProgress = async () => {
        try {
          const progressResponse = await fetch(`/api/video-progress/${jobId}`)
          
          if (!progressResponse.ok) {
            console.error(`❌ Progress request failed: ${progressResponse.status}`)
            throw new Error(t('failedToGetProgress'))
          }

          const progressData = await progressResponse.json()
          
          if (progressData.status === 'error') {
            console.error('❌ Video processing error:', progressData.message)
            throw new Error(progressData.message || t('videoProcessingFailed'))
          }
          
          setGenerationProgress(progressData.progress || 0)

          if (progressData.status === 'completed' && progressData.videoData) {
            const newVideoData = {
              url: progressData.videoData.url,
              tempUrl: progressData.videoData.tempUrl,
              filename: progressData.videoData.filename,
              fileSize: progressData.videoData.size
            }
            setLocalVideoData(newVideoData)
            setVideo(newVideoData) // Update context
            setIsProcessing(false)
            setGenerationProgress(100)
            setCurrentJobId(null) // Clear job ID when completed
          } else if (progressData.status === 'processing' || progressData.status === 'initializing') {
            setTimeout(pollProgress, 1000)
          }
        } catch (error) {
          console.error('Progress polling error:', error)
          setIsProcessing(false)
          showErrorMessage(error.message || t('unknownErrorOccurred'))
        }
      }

      // Start polling
      setTimeout(pollProgress, 1000)

    } catch (error) {
      console.error('Video generation error:', error)
      setIsProcessing(false)
      showErrorMessage(error.message || t('generationFailed'))
    }
  }

  // Detect mobile
  const [isMobile, setIsMobile] = React.useState(false)

  React.useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  return (
    <div className="p-6 space-y-6 h-full overflow-y-auto">
      {/* Status Badges - Always show when no video is generated */}
      {!localVideoData && (
        <motion.div
          className="flex flex-wrap items-center justify-center gap-2"
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
        >
          {/* Music Badge */}
          {selectedMusic && (
            <motion.div
              className="inline-flex items-center bg-white/10 backdrop-blur-sm rounded-full px-4 py-2 border border-white/20"
              initial={{ scale: 0.9, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              transition={{ delay: 0.1 }}
            >
              <svg className="w-4 h-4 text-green-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM15.657 6.343a1 1 0 011.414 0A9.972 9.972 0 0119 12a9.972 9.972 0 01-1.929 5.657 1 1 0 11-1.414-1.414A7.971 7.971 0 0017 12a7.971 7.971 0 00-1.343-4.243 1 1 0 010-1.414z" clipRule="evenodd" />
              </svg>
              <span className="text-white/90 text-sm font-medium">{t('musicAdded')}</span>
            </motion.div>
          )}

          {/* Photos Badge */}
          {photos?.length > 0 && (
            <motion.div
              className="inline-flex items-center bg-white/10 backdrop-blur-sm rounded-full px-4 py-2 border border-white/20"
              initial={{ scale: 0.9, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              transition={{ delay: 0.2 }}
            >
              <svg className="w-4 h-4 text-blue-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clipRule="evenodd" />
              </svg>
              <span className="text-white/90 text-sm font-medium">{photos.length} {photos.length === 1 ? t('photo') : t('photos')}</span>
            </motion.div>
          )}
        </motion.div>
      )}

      {/* Inline Circular Progress - Below badges */}
      {isProcessing && (
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.8 }}
          className="flex justify-center"
        >
          <div className="relative w-20 h-20">
            <svg className="w-20 h-20 transform -rotate-90">
              <circle
                cx="40"
                cy="40"
                r="32"
                stroke="currentColor"
                strokeWidth="6"
                fill="none"
                className="text-gray-700"
              />
              <motion.circle
                cx="40"
                cy="40"
                r="32"
                stroke="currentColor"
                strokeWidth="6"
                fill="none"
                strokeLinecap="round"
                className="text-blue-500"
                style={{
                  strokeDasharray: "201",
                  strokeDashoffset: 201 - (201 * generationProgress) / 100
                }}
              />
            </svg>
            <div className="absolute inset-0 flex items-center justify-center">
              <span className="text-white font-semibold text-sm">{Math.round(generationProgress)}%</span>
            </div>
          </div>
        </motion.div>
      )}

      {/* Error Message */}
      <AnimatePresence>
        {showError && generationError && (
          <motion.div
            initial={{ opacity: 0, y: -20, scale: 0.95 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -20, scale: 0.95 }}
            className="bg-gradient-to-r from-red-500/10 to-rose-500/10 border border-red-400/30 rounded-xl p-4"
          >
            <div className="flex items-center space-x-3">
              <svg className="w-5 h-5 text-red-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              <span className="text-red-300 text-sm">{generationError}</span>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Video Ready - Download Options */}
      {localVideoData && !isProcessing && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="space-y-6"
        >
          {/* Success Message - Auto-hide after 2 seconds */}
          <AnimatePresence>
            {showSuccessMessage && (
              <motion.div
                initial={{ opacity: 0, scale: 0.95 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.95 }}
                transition={{ duration: 0.3 }}
                className="bg-gradient-to-r from-green-500/10 to-emerald-500/10 border border-green-400/30 rounded-xl p-4"
              >
                <div className="flex items-center space-x-3">
                  <svg className="w-6 h-6 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                  <span className="text-green-300 font-medium">{t('videoGeneratedSuccessfully')}</span>
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* QR Code Display - Minimalist */}
          <AnimatePresence>
            {showQrCode && qrCodeDataUrl && (
              <motion.div 
                className="flex justify-center"
                initial={{ opacity: 0, scale: 0.8, y: 20 }}
                animate={{ opacity: 1, scale: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.8, y: -20 }}
                transition={{ duration: 0.3 }}
              >
                <div className="bg-white rounded-lg p-2">
                  <img 
                    src={qrCodeDataUrl} 
                    alt="QR Code" 
                    className="w-24 h-24"
                  />
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* All Action Buttons - Single Column, Centered */}
          <motion.div 
            className="flex flex-col items-center space-y-3 w-full max-w-xs mx-auto"
            initial={{ scale: 0.95 }}
            animate={{ scale: 1 }}
            transition={{ duration: 0.3 }}
          >
            {/* Download Button */}
            <motion.button
              onClick={handleDownload}
              className="w-full bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-700 hover:to-cyan-700 text-white font-semibold py-3 px-4 rounded-xl shadow-lg transition-all duration-300 flex items-center justify-center space-x-2"
              whileHover={{ scale: 1.02, boxShadow: "0 10px 30px -10px rgba(59, 130, 246, 0.4)" }}
              whileTap={{ scale: 0.98 }}
            >
              <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
              </svg>
              <span className="text-sm">Download</span>
            </motion.button>

            {/* QR Code Button */}
            <motion.button
              onClick={handleQRToggle}
              disabled={loadingQR}
              className="w-full bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed text-white font-semibold py-3 px-4 rounded-xl shadow-lg transition-all duration-300 flex items-center justify-center space-x-2"
              whileHover={!loadingQR ? { scale: 1.02, boxShadow: "0 10px 30px -10px rgba(34, 197, 94, 0.4)" } : {}}
              whileTap={!loadingQR ? { scale: 0.98 } : {}}
            >
              {loadingQR ? (
                <>
                  <motion.div
                    className="w-4 h-4 border-2 border-white border-t-transparent rounded-full"
                    animate={{ rotate: 360 }}
                    transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
                  />
                </>
              ) : (
                <>
                  <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M3 11h8V3H3v8zm2-6h4v4H5V5zM13 3v8h8V3h-8zm6 6h-4V5h4v4zM3 21h8v-8H3v8zm2-6h4v4H5v-4z"/>
                    <path d="M15 19h2v2h-2zM19 19h2v2h-2zM17 17h2v2h-2zM15 15h2v2h-2zM17 21h2v2h-2z"/>
                  </svg>
                  <span className="text-sm">{showQrCode ? t('hideQR') : 'QR Code'}</span>
                </>
              )}
            </motion.button>

            {/* New Video Button */}
            <motion.button
              onClick={onNewVideo}
              className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 px-4 rounded-xl font-semibold hover:shadow-lg hover:shadow-purple-500/25 transition-all duration-200 flex items-center justify-center space-x-2"
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
              </svg>
              <span className="text-sm">{t('createNewVideo')}</span>
            </motion.button>
          </motion.div>
        </motion.div>
      )}

      {/* No Video Yet - Generate Button */}
      {!localVideoData && !isProcessing && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="space-y-4"
        >
          <motion.button
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            onClick={handleGenerateVideo}
            disabled={!photos?.length || !selectedMusic}
            className="w-full bg-gradient-to-r from-blue-500 to-cyan-500 disabled:from-gray-600 disabled:to-gray-700 text-white py-4 px-6 rounded-xl font-medium hover:shadow-lg hover:shadow-blue-500/25 transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50"
          >
            {t('generateVideo')}
          </motion.button>

          {(!photos?.length || !selectedMusic) && (
            <p className="text-white/50 text-sm text-center">
              {t('pleaseFillRequirements')}
            </p>
          )}
        </motion.div>
      )}

    </div>
  )
}

export default VideoExportSidebar